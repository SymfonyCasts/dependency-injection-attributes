# Lazy Services

It's time to talk about one of my favorite Symfony features: lazy services. Many
times, you inject a service, but it's only used under certain conditions. For example,
a controller that caches some expensive operation. You inject the cache pool and
the service that performs this operation. If the cache is hit, you don't need that
service, but it's still instantiated and that *could* be expensive.

A "lazy service" gets to relax on the couch, eating potato chips, until it's actually needed.

Let's look at an example. Create a new PHP class in `src/Remote` called
`ParentalControls`. This will be a service to send us alerts when the kids
are doing something they shouldn't. Mark this class as `final` and add a constructor
with a single argument: `private MailerInterface $mailer`.
These alerts will be sent via email.

Add a new public method called `volumeTooHigh()` with a `void` return type. Inside,
to represent sending the email, just write `dump('send volume alert email')`.

We'll use this in our `VolumeUpButton`. Open that, add a constructor, and inject
`private ParentalControls $parentalControls`.

In the `press()` method, we'll pretend we're detecting when the volume is too high.
Add an `if (true)` statement (with a comment to remind us what this represents),
and call `$this->parentalControls->volumeTooHigh()` inside.

Spin over to our app, refresh, press the "volume up" button, and check the profiler.
We can see our `ParentalControls` service is being used and working as expected.

Now, back in `VolumeUpButton`, switch `true` to `false` to pretend we didn't detect
a high volume. Below the if statement, write `dump($this->parentalControls)`.

Now, back in our app, press "volume up" and check the profiler. Even though we didn't
use `ParentalControls`, it was still instantiated, So was the mailer service it depends
on, the mailer transport, and so on. This is a long chain of dependencies
that were instantiated but not used!

We need to make `ParentalControls` a lazy service. Open that class and add the `#[Lazy]`
attribute to it.

Back in our app, refresh, press "volume up", and... an error!

> Cannot generate lazy proxy for service "ParentalControls".

Check the previous exception to see why:

> Cannot generate lazy proxy: class "ParentalControls" is final.

This is a minor downside of using lazy services this way: the class cannot be final.
We'll see why in a second.

Open `ParentalControls`, remove final, and refresh the app. We're good!

Press "volume up" and check the profiler.

Whoa! What's this? `ParentalControlsGhost` with a random string after it? This is something
called a "ghost proxy" and it's generated by Symfony. It extends our `ParentalControls`
class (which is why it can't be final) and, until it's actually used, is not fully
instantiated - a ghost! Spooky!

What if we didn't "own" `ParentalControls`? What if it was part of a 3rd party package?
How could we make it lazy? We can't edit vendor code. The `#[Lazy]` attribute can be
used on an argument to make it lazy on a per-use basis.

In `ParentalControls`, remove `#[Lazy]` and in `VolumeUpButton`, add `#[Lazy]` above
the `$parentalControls` argument.

In our app, refresh, press "volume up", and check the profiler. It's still lazy!

When you add the `#[Lazy]` attribute to a class, all instances of that service are lazy.
When you add it to an argument, it's lazy only when used in that context.

What if it existed in a 3rd party package *and* was final? Are we out of luck?

Nope! Symfony has a few other tricks, and attributes, up its sleeve to help with laziness.
Let's check those out next!
